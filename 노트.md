functools.reduce(function, iterable[, initializer]):
iterable의 값을 왼쪽에서부터 오른쪽으로 function의 인자로 넣어 결과를 반환하는 함수

from functools import reduce
nums = [1, 2, 3, 4]
def sum(a, b):
return a + b
def mul(a, b):
return a _ b
print(reduce(sum, nums)) # (((1 + 2) + 3) + 4)
print(reduce(mul, nums)) # (((1 _ 2) _ 3) _ 4)
연산자 함수를 사용할수도 있음
print(reduce(operator.mul, nums)) # (((1 _ 2) _ 3) \* 4)

현재 널리쓰이는 IEEE754는 실수에 4, 8byte의 메모리를 할당하므로 실수를 표현할때 부정확할수 있다
ex. 0.3 + 0.6 = .89999999999999
0.3 + 0.6 == 0.9 # False
이럴경우 round함수를 사용해서 실수를 비교할수 있음

- f-string
  자바스크립트의 `${}`처럼 문자열안에 변수를 넣을수 있게 해줌
  문자열앞에 f를 넣어주면 됨
  print(f"string {variable}")

- 람다 표현식
  def add(a, b): a + b
  (lambda a, b: a + b)
  위의 두 코드는 똑같은 역할을 함

- Counter
  원소의 등장횟수를 셀때 사용
  dict로도 변환하여 갯수를 볼수있음

- 최소공배수와 최대공약수
  math라이브러리의 gcd() 함수를 통해 최대공약수를 구할수있음
  최소공배수의 공식을 이용해서 최대공약수를 구할수있음
  def lcm(a, b): return a \* b // math.gcd(a, b)

- 유클리드 호제법
  두 자연수 a를 b로 나눈 나머지를 r이라고 한다. (a > b)
  a와 a \* b의 최대공약수는 b와 r의 최대공약수와 같다.

- 재귀 함수
  함수를 연속적으로 호출하면 메모리의 스택프레임에 쌓인다.

- DFS (Depth First Search)

1. 시작 노드를 스택에 넣고 방문처리
2. 스택에서 노드를 꺼내 방문처리하고 인접한 노드가있다면 스택에 추가
3. 스택에 노드가 없을때까지 2를 반복

- BFS (Breadth First Search)

1. 시작 노드를 큐에 넣고 방문처리
2. 큐의 처음노드를 꺼내 방문처리하고 인접한 노드가 있다면 큐에 추가
3. 큐에 노드가 없을때까지 2를 반복

- 몫과 나머지 한번에 구하는 법
  divmod()함수를 사용하면 몫과 나머지를 튜플로 반환시켜준다
  ex. divmod(3, 1) => (3, 0)

- 디버깅 팁
  locals() 함수를 사용하면 로컬에 선언된 모든 변수를 가져온다.
  pprint를 import해서 사용하면 줄바꿈처리를 해주기떄문에 가독성이좋아진다.
  ex.
  import pprint
  pprint.pprint(locals())

- 트리 순회
  전위순회 (NLR)
  중위순회 (LNR)
  후위순회 (LRN)
  L은 현재노드의 왼쪽노드 R은 현재노드의 오른쪽노드 N은 현재노드를 나타냄, 전위순회 NLR은 현재노드를 순회하고 왼쪽노드, 오른쪽노드 순으로 순회함

NLR sudocode
preorder(node)
-if node == Null
--return
-node.val
-preorder(node.left)
-preorder(node.right)

LNR sudocode
inorder(node)
-if node == Null
--return
-inorder(node.left)
-node.val
-inorder(node.right)

LRN sudocode
postorder(node)
-if node == Null
--return
-postorder(node.left)
-postorder(node.right)
-node.val

## 파이썬 딕셔너리 입력 순서 유지

파이썬의 딕셔너리는 3.7버젼부터 딕셔너리의 입력순서가 유지되도록 변경돼었다.  
파이썬 3.7미만 버젼에서 딕셔너리의 입력순서를 유지하려면 collections.OrderedDict를 사용하면 된다.
